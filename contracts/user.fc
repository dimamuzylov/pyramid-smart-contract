#include "imports/stdlib.fc";
#include "imports/methods.fc";
#include "imports/functions.fc";
#include "imports/const.fc";
#include "imports/storage.fc";

slice _get_user(slice address) inline {
    (slice value, int found) = db::users.dict_get?(ADDRESS_SIZE, pack_address(address));
    return value;
}

int _is_user_exist(slice address) inline {
    (slice value, int found) = db::users.dict_get?(ADDRESS_SIZE, pack_address(address));
    return found;
}

() user::deposit(slice address, int amount, int days) impure inline_ref {
    throw_if(exit::invalid_deposit(), amount < oneton());
    throw_if(exit::invalid_deposit(), amount > fiftyton());
    throw_if(exit::invalid_deposit(), _is_user_exist(address) == -1);

    throw_if(exit::invalid_deposit_time(), days < db::min_days);
    throw_if(exit::invalid_deposit_time(), days > db::max_days);

    builder value = begin_cell()
        .store_int(now(), 64)
        .store_coins(amount)
        .store_int(days, 32);
    db::users~dict_set_builder(ADDRESS_SIZE, pack_address(address), value);
}

() user::withdraw(slice address) impure inline_ref {    
    throw_if(exit::invalid_withdraw(), _is_user_exist(address) == 0);

    slice user = _get_user(address);
    int time = user~load_uint(64);
    int amount = user~load_coins();
    int days = user~load_uint(32);

    int freeze_time = time + days * 60 * 60 * 24; ;; user deposit time + days to freeze

    throw_if(exit::invalid_withdraw_time(), freeze_time >= now());
    
    int prize_amount_in_precentage = days * db::daily_percent;
    int prize_amount = (amount * prize_amount_in_precentage) / 100;

    int withdraw_amount = amount + prize_amount;

    var [balance, _] = get_balance();
    throw_unless(exit::lack_of_balance(), balance >= withdraw_amount);
    
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(address)
        .store_coins(withdraw_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();

    send_raw_message(msg, 3);

    db::users~dict_delete?(ADDRESS_SIZE, pack_address(address));
}